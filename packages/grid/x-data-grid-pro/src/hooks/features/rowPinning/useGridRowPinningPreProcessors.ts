import * as React from 'react';
import {
  getRowIdFromRowModel,
  GridHydrateRowsValue,
  GridPipeProcessor,
  useGridRegisterPipeProcessor,
} from '@mui/x-data-grid/internals';
import { GridRowId, GridRowModel } from '@mui/x-data-grid';
import { GridApiPro } from '../../../models/gridApiPro';
import { DataGridProProcessedProps } from '../../../models/dataGridProProps';
import { GridPinnedRowsProp } from './gridRowPinningInterface';

type GridPinnedRowPosition = keyof GridPinnedRowsProp;

export function addPinnedRow({
  groupingParams,
  rowModel,
  rowId,
  position,
  apiRef,
}: {
  groupingParams: GridHydrateRowsValue;
  rowModel: GridRowModel;
  rowId: GridRowId;
  position: GridPinnedRowPosition;
  apiRef: React.MutableRefObject<GridApiPro>;
}) {
  const idRowsLookup = { ...groupingParams.idRowsLookup };
  const tree = { ...groupingParams.tree };

  // TODO: warn if id is already present in `props.rows`
  idRowsLookup[rowId] = rowModel;
  // Do not push it to ids list so that pagination is not affected by pinned rows
  // ids.push(rowId);
  tree[rowId] = {
    id: rowId,
    isAutoGenerated: false,
    parent: null,
    depth: 0,
    groupingKey: null,
    groupingField: null,
    isPinned: true,
  };

  apiRef.current.unstable_caches.rows.idRowsLookup[rowId] = { ...rowModel };
  apiRef.current.unstable_caches.rows.idToIdLookup[rowId] = rowId;

  const previousPinnedRows = groupingParams.additionalRowGroups?.pinnedRows || {};

  return {
    ...groupingParams,
    idRowsLookup,
    tree,
    additionalRowGroups: {
      ...groupingParams.additionalRowGroups,
      pinnedRows: {
        ...previousPinnedRows,
        [position]: [
          ...(previousPinnedRows[position] || []),
          {
            id: rowId,
            rowModel,
          },
        ],
      },
    },
  };
}

export const useGridRowPinningPreProcessors = (
  apiRef: React.MutableRefObject<GridApiPro>,
  props: Pick<DataGridProProcessedProps, 'pinnedRows' | 'getRowId'>,
) => {
  const addPinnedRows = React.useCallback<GridPipeProcessor<'hydrateRows'>>(
    (groupingParams) => {
      const pinnedRows = apiRef.current.unstable_caches.pinnedRows;
      const pinnedRowsTop = pinnedRows?.top || [];
      const pinnedRowsBottom = pinnedRows?.bottom || [];

      let newGroupingParams = {
        ...groupingParams,
        additionalRowGroups: {
          ...groupingParams.additionalRowGroups,
          // reset pinned rows state
          pinnedRows: {},
        },
      };

      pinnedRowsTop.forEach((row) => {
        const rowId = getRowIdFromRowModel(row, props.getRowId);
        newGroupingParams = addPinnedRow({
          groupingParams: newGroupingParams,
          rowModel: row,
          rowId,
          position: 'top',
          apiRef,
        });
      });
      pinnedRowsBottom.forEach((row) => {
        const rowId = getRowIdFromRowModel(row, props.getRowId);
        newGroupingParams = addPinnedRow({
          groupingParams: newGroupingParams,
          rowModel: row,
          rowId,
          position: 'bottom',
          apiRef,
        });
      });

      return newGroupingParams;
    },
    [apiRef, props.getRowId],
  );

  useGridRegisterPipeProcessor(apiRef, 'hydrateRows', addPinnedRows);
};
